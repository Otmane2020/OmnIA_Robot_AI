const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization",
};

interface VisionExtractionRequest {
  image_url?: string;
  image_base64?: string;
  product_title?: string;
  product_description?: string;
}

interface ExtractedAttributes {
  colors: string[];
  materials: string[];
  style: string;
  category: string;
  subcategory: string;
  room: string;
  features: string[];
  dimensions: string;
  confidence_score: number;
}

Deno.serve(async (req: Request) => {
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 200,
      headers: corsHeaders,
    });
  }

  try {
    const { image_url, image_base64, product_title, product_description }: VisionExtractionRequest = await req.json();

    console.log('üëÅÔ∏è Vision AI extraction demand√©e');

    const openaiApiKey = Deno.env.get('OPENAI_API_KEY');
    
    if (!openaiApiKey) {
      console.log('‚ùå Cl√© API OpenAI manquante');
      return new Response(
        JSON.stringify({ 
          error: "Cl√© API OpenAI non configur√©e pour Vision",
          fallback_attributes: generateFallbackAttributes(product_title, product_description)
        }),
        {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Pr√©parer l'image pour GPT Vision
    const imageContent = image_base64 ? 
      { type: "image_url", image_url: { url: `data:image/jpeg;base64,${image_base64}` } } :
      { type: "image_url", image_url: { url: image_url } };

    const prompt = `Analyse cette image de produit mobilier et extrait les attributs pr√©cis au format JSON strict.

PRODUIT: ${product_title || 'Non sp√©cifi√©'}
DESCRIPTION: ${product_description || 'Non sp√©cifi√©e'}

Analyse l'image et extrait EXACTEMENT ces attributs au format JSON :
{
  "colors": ["couleur1", "couleur2", "couleur3"],
  "materials": ["mat√©riau1", "mat√©riau2"],
  "style": "moderne|contemporain|scandinave|industriel|vintage|rustique|classique|minimaliste|boh√®me",
  "category": "Fauteuil|Canap√©|Table|Chaise|Lit|Rangement|Meuble TV|D√©coration",
  "subcategory": "Description pr√©cise du type",
  "room": "salon|chambre|cuisine|bureau|salle √† manger|entr√©e|terrasse",
  "features": ["convertible", "rangement", "r√©glable", "pivotant"],
  "dimensions": "LxlxH en cm ou description",
  "confidence_score": 85
}

R√àGLES STRICTES pour l'analyse visuelle :
- colors: TOUTES les couleurs visibles (ex: ["turquoise", "blanc", "noir"] pour un fauteuil turquoise avec pieds noirs)
- materials: TOUS les mat√©riaux visibles (ex: ["r√©sine", "acier"] pour assise r√©sine + pieds acier)
- style: Style design dominant visible
- category: Type de meuble principal
- subcategory: Description pr√©cise (ex: "Fauteuil design moderne", "Chaise de bureau ergonomique")
- room: Pi√®ce d'usage principal
- features: Fonctionnalit√©s visibles ou d√©ductibles
- dimensions: Si visible ou estimable
- confidence_score: 0-100 bas√© sur la clart√© de l'image

EXEMPLE pour "Fauteuil turquoise avec pieds acier" :
{
  "colors": ["turquoise", "noir"],
  "materials": ["r√©sine", "acier"],
  "style": "moderne",
  "category": "Fauteuil",
  "subcategory": "Fauteuil design moderne",
  "room": "salon",
  "features": ["design", "confort"],
  "dimensions": "estim√© 60x60x80cm",
  "confidence_score": 90
}

R√âPONSE JSON UNIQUEMENT:`;

    console.log('üîÑ Envoi √† GPT Vision...');

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openaiApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o', // GPT-4 avec Vision
        messages: [
          {
            role: 'system',
            content: 'Tu es un expert en mobilier et design d\'int√©rieur. Tu analyses les images de meubles et extrais TOUS les attributs visibles au format JSON strict. Sois tr√®s pr√©cis sur les couleurs et mat√©riaux.'
          },
          {
            role: 'user',
            content: [
              {
                type: "text",
                text: prompt
              },
              imageContent
            ]
          }
        ],
        max_tokens: 500,
        temperature: 0.1, // Tr√®s bas pour coh√©rence
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Erreur GPT Vision:', response.status, errorText);
      
      return new Response(
        JSON.stringify({ 
          error: "Erreur GPT Vision API",
          details: errorText,
          fallback_attributes: generateFallbackAttributes(product_title, product_description)
        }),
        {
          status: response.status,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    const data = await response.json();
    const content = data.choices[0]?.message?.content?.trim();

    if (content) {
      try {
        const extractedAttributes = JSON.parse(content);
        console.log('‚úÖ Attributs extraits par Vision AI:', extractedAttributes);

        return new Response(
          JSON.stringify({ 
            success: true,
            attributes: extractedAttributes,
            extraction_method: 'vision_ai',
            processed_at: new Date().toISOString()
          }),
          {
            headers: {
              'Content-Type': 'application/json',
              ...corsHeaders,
            },
          }
        );
      } catch (parseError) {
        console.error('‚ùå JSON invalide:', parseError);
      }
    }

    // Fallback si parsing √©choue
    const fallbackAttributes = generateFallbackAttributes(product_title, product_description);
    
    return new Response(
      JSON.stringify({ 
        success: true,
        attributes: fallbackAttributes,
        extraction_method: 'fallback',
        processed_at: new Date().toISOString()
      }),
      {
        headers: {
          'Content-Type': 'application/json',
          ...corsHeaders,
        },
      }
    );

  } catch (error) {
    console.error('‚ùå Erreur serveur Vision:', error);
    
    return new Response(
      JSON.stringify({ 
        error: "Erreur serveur lors de l'extraction visuelle",
        details: error.message,
        fallback_attributes: generateFallbackAttributes(product_title || '', product_description || '')
      }),
      {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});

function generateFallbackAttributes(title: string = '', description: string = ''): ExtractedAttributes {
  const text = `${title} ${description}`.toLowerCase();
  
  // Extraction basique depuis le texte
  const colors = [];
  const materials = [];
  let style = '';
  let category = 'Mobilier';
  let subcategory = '';
  let room = '';
  const features = [];
  
  // Couleurs
  if (text.includes('turquoise')) colors.push('turquoise');
  if (text.includes('blanc') || text.includes('white')) colors.push('blanc');
  if (text.includes('noir') || text.includes('black')) colors.push('noir');
  if (text.includes('gris') || text.includes('grey')) colors.push('gris');
  if (text.includes('beige')) colors.push('beige');
  if (text.includes('bleu') || text.includes('blue')) colors.push('bleu');
  
  // Mat√©riaux
  if (text.includes('r√©sine') || text.includes('resin')) materials.push('r√©sine');
  if (text.includes('acier') || text.includes('steel')) materials.push('acier');
  if (text.includes('m√©tal') || text.includes('metal')) materials.push('m√©tal');
  if (text.includes('bois') || text.includes('wood')) materials.push('bois');
  if (text.includes('velours')) materials.push('velours');
  if (text.includes('tissu')) materials.push('tissu');
  if (text.includes('cuir')) materials.push('cuir');
  if (text.includes('travertin')) materials.push('travertin');
  if (text.includes('marbre')) materials.push('marbre');
  
  // Style
  if (text.includes('moderne') || text.includes('modern')) style = 'moderne';
  else if (text.includes('contemporain')) style = 'contemporain';
  else if (text.includes('scandinave')) style = 'scandinave';
  else if (text.includes('industriel')) style = 'industriel';
  else if (text.includes('vintage')) style = 'vintage';
  
  // Cat√©gorie
  if (text.includes('fauteuil') || text.includes('armchair')) {
    category = 'Fauteuil';
    subcategory = 'Fauteuil design moderne';
    room = 'salon';
  } else if (text.includes('canap√©') || text.includes('sofa')) {
    category = 'Canap√©';
    if (text.includes('angle')) subcategory = 'Canap√© d\'angle';
    else if (text.includes('convertible')) subcategory = 'Canap√© convertible';
    else subcategory = 'Canap√© fixe';
    room = 'salon';
  } else if (text.includes('table')) {
    category = 'Table';
    if (text.includes('basse')) subcategory = 'Table basse';
    else if (text.includes('manger')) subcategory = 'Table √† manger';
    else subcategory = 'Table';
    room = 'salon';
  } else if (text.includes('chaise') || text.includes('chair')) {
    category = 'Chaise';
    if (text.includes('bureau')) subcategory = 'Chaise de bureau';
    else subcategory = 'Chaise de salle √† manger';
    room = 'salle √† manger';
  }
  
  // Fonctionnalit√©s
  if (text.includes('convertible')) features.push('convertible');
  if (text.includes('rangement')) features.push('rangement');
  if (text.includes('r√©glable')) features.push('r√©glable');
  if (text.includes('pivotant')) features.push('pivotant');
  if (text.includes('roulettes')) features.push('roulettes');
  if (text.includes('confort')) features.push('confort');
  if (text.includes('design')) features.push('design');
  
  // Dimensions basiques
  const dimensionMatch = text.match(/(\d+)\s*[x√ó]\s*(\d+)(?:\s*[x√ó]\s*(\d+))?\s*cm/);
  const dimensions = dimensionMatch ? dimensionMatch[0] : '';
  
  // Score de confiance
  let confidence = 30;
  if (colors.length > 0) confidence += 25;
  if (materials.length > 0) confidence += 25;
  if (style) confidence += 15;
  if (category !== 'Mobilier') confidence += 15;
  if (room) confidence += 10;
  
  return {
    colors,
    materials,
    style,
    category,
    subcategory,
    room,
    features,
    dimensions,
    confidence_score: Math.min(confidence, 100)
  };
}